"""Integration tests for map lookup functionality with substitutions."""

import pytest
import tempfile
from pathlib import Path

from lhp.utils.substitution import EnhancedSubstitutionManager


class TestSubstitutionMapLookupIntegration:
    """Test map lookups work end-to-end with substitutions."""
    
    def test_substitute_config_with_map_lookups(self):
        """Complete config substitution with map lookups."""
        with tempfile.NamedTemporaryFile(mode='w', suffix='.yaml', delete=False) as f:
            config = """
dev:
  catalog: dev_catalog
  paths:
    bronze: bronze_layer
    silver: silver_layer
    gold: gold_layer
"""
            f.write(config)
            f.flush()
            
            try:
                mgr = EnhancedSubstitutionManager(Path(f.name), env="dev")
                
                # Config with map lookups
                data = {
                    "target": "{catalog}.{paths[bronze]}.customers",
                    "description": "Load to {paths[bronze]}"
                }
                
                # Substitute
                result = mgr.substitute_yaml(data)
                
                # Verify map lookups resolved
                assert result["target"] == "dev_catalog.bronze_layer.customers"
                assert result["description"] == "Load to bronze_layer"
            finally:
                import os
                os.unlink(f.name)
    
    def test_map_lookup_in_nested_dict(self):
        """Map lookups in nested dictionaries."""
        with tempfile.NamedTemporaryFile(mode='w', suffix='.yaml', delete=False) as f:
            config = """
dev:
  catalog: main
  schemas:
    bronze: bronze_db
    silver: silver_db
"""
            f.write(config)
            f.flush()
            
            try:
                mgr = EnhancedSubstitutionManager(Path(f.name), env="dev")
                
                data = {
                    "write_target": {
                        "database": "{catalog}.{schemas[silver]}",
                        "table": "customers"
                    }
                }
                
                result = mgr.substitute_yaml(data)
                
                assert result["write_target"]["database"] == "main.silver_db"
                assert result["write_target"]["table"] == "customers"
            finally:
                import os
                os.unlink(f.name)
    
    def test_nested_map_lookup(self):
        """Nested map lookups like {config[jdbc][host]}."""
        with tempfile.NamedTemporaryFile(mode='w', suffix='.yaml', delete=False) as f:
            config = """
dev:
  config:
    jdbc:
      host: dev-mysql.company.com
      port: 3306
"""
            f.write(config)
            f.flush()
            
            try:
                mgr = EnhancedSubstitutionManager(Path(f.name), env="dev")
                
                data = {
                    "source": {
                        "jdbc_url": "jdbc:mysql://{config[jdbc][host]}:{config[jdbc][port]}/mydb"
                    }
                }
                
                result = mgr.substitute_yaml(data)
                
                assert result["source"]["jdbc_url"] == \
                    "jdbc:mysql://dev-mysql.company.com:3306/mydb"
            finally:
                import os
                os.unlink(f.name)
    
    def test_unresolved_map_lookup_detected(self):
        """Unresolved map lookups are detected by validation."""
        with tempfile.NamedTemporaryFile(mode='w', suffix='.yaml', delete=False) as f:
            config = """
dev:
  catalog: main
"""
            f.write(config)
            f.flush()
            
            try:
                mgr = EnhancedSubstitutionManager(Path(f.name), env="dev")
                
                data = {
                    "target": "{catalog}.{missing_paths[bronze]}.customers"
                }
                
                # Substitute (will leave unresolved)
                result = mgr.substitute_yaml(data)
                
                # Validation should detect unresolved token
                errors = mgr.validate_no_unresolved_tokens(result)
                
                assert len(errors) == 1
                assert "missing_paths[bronze]" in errors[0]
            finally:
                import os
                os.unlink(f.name)
    
    def test_map_lookup_with_recursive_expansion(self):
        """Map lookups that reference other tokens."""
        with tempfile.NamedTemporaryFile(mode='w', suffix='.yaml', delete=False) as f:
            config = """
dev:
  bucket: my-datalake
  base_path: s3://{bucket}/data
  paths:
    bronze: "{base_path}/bronze"
    silver: "{base_path}/silver"
"""
            f.write(config)
            f.flush()
            
            try:
                mgr = EnhancedSubstitutionManager(Path(f.name), env="dev")
                
                data = {
                    "target": "{paths[bronze]}/customers"
                }
                
                result = mgr.substitute_yaml(data)
                
                # Should expand recursively: {paths[bronze]} -> {base_path}/bronze -> s3://my-datalake/data/bronze
                assert result["target"] == "s3://my-datalake/data/bronze/customers"
            finally:
                import os
                os.unlink(f.name)


if __name__ == "__main__":
    pytest.main([__file__, "-v"])

